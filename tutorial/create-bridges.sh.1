#!/bin/bash

# Enable for debugging
# set -x

## --------------- ##
## Local Functions ##
## --------------- ##

gen_ips() {
  local cidr="$1" ; local lo hi a b c d e f g h

  # range is bounded by network (-n) & broadcast (-b) addresses.
  lo=$(ipcalc -n "$cidr" | cut -f2 -d=)
  hi=$(ipcalc -b "$cidr" | cut -f2 -d=)

  IFS=. read -r a b c d <<< "$lo"
  IFS=. read -r e f g h <<< "$hi"

  eval "echo {$a..$e}.{$b..$f}.{$c..$g}.{$d..$h}"
}

# gen_ips 192.168.128.0/17


## ------------- ##
## LSB functions ##
## ------------- ##

## Use the system's own implementations if it has any.
#if [ -e /etc/init.d/functions ]; then
#    . /etc/init.d/functions
#elif [ -e /etc/rc.d/init.d/functions ]; then
#    . /etc/rc.d/init.d/functions
#elif [ -e /lib/lsb/init-functions ]; then
#    . /lib/lsb/init-functions
#fi

# Implement missing functions (e.g. OpenSUSE lacks 'action').
if type log_success_msg >/dev/null 2>&1; then :; else
    log_success_msg () {
        printf '%s.\n' "$*"
    }
fi
if type log_failure_msg >/dev/null 2>&1; then :; else
    log_failure_msg () {
        printf '%s ... failed!\n' "$*"
    }
fi
if type log_warning_msg >/dev/null 2>&1; then :; else
    log_warning_msg () {
        printf '%s ... (warning).\n' "$*"
    }
fi
if type action >/dev/null 2>&1; then :; else
    action () {
       STRING=$1
       shift
       "$@"
       rc=$?
       if test $rc = 0; then
            log_success_msg "$STRING"
       else
            log_failure_msg "$STRING"
       fi
       return $rc
    }
fi

# Test the message printing functions
#log_success_msg "This is a success message"
#log_failure_msg "This is a failure message"
#log_warning_msg "This is a warning message"
#action "Running a successful action" sleep 1
#action "Running a failing action" false

# Make sure we're running as root
[ "$EUID" -eq 0 ] || exec sudo bash "$0" "$@"

# We expect to be running in the OVN sandbox environment here,
# patchs for OVS and OVN tools are already setup.

# Pull-in customizations from the shared variables file
if [ -f ./vars ]; then
  source ./vars
else
  log_failure_msg "Can't find vars file at $PWD/vars"
  exit 1
fi

# ToDo: Reconsider using global variables here
RANDOM_MACS=()
UNIQUE_MACS=()
MAC_PREFIX="00:10:18"
#
# Generate an array of random MAC addresses.
#
gen_macs() {
  local mac_count=$1
  # ToDo: Find a better solution for avoiding address collisions
  for (( m = 1; m <= $mac_count + 5; m++ )); do
    RANDOM_MACS[$m]="$(printf '%s:%02X:%02X:%02X' $MAC_PREFIX $[RANDOM%256] $[RANDOM%256] $[RANDOM%256])"
  done
  UNIQUE_MACS=( $(echo ${RANDOM_MACS[@]} | tr [:space:] '\n' | awk '!a[$0]++'))

  # ToDo: Fix the problem instead of just reporting an error
  if [ "${#UNIQUE_MACS[@]}" -lt "$mac_count" ]; then
    log_failure_msg "Failed to generate $mac_count random MAC addresses"
  fi

  # Trim extra elements at the end of the array
  UNIQUE_MACS=( "${UNIQUE_MACS[@]::$mac_count}" )

  # print the results
  # echo "${UNIQUE_MACS[@]}"
}

mac_count=$((MAX_LOGICAL_SWITCHES + (MAX_LOGICAL_SWITCHES * MAX_PORTS_PER_LOGICAL_SWITCH)))
gen_macs $mac_count
log_success_msg "Generated $mac_count random MAC addresses"


IPS=()
#
# Generate an array of IPv4 addresses.
#
gen_ips() {
  local cidr="$1" ; local lo hi a b c d e f g h

  # range is bounded by network (-n) & broadcast (-b) addresses.
  lo=$(ipcalc -n "$cidr" | cut -f2 -d=)
  hi=$(ipcalc -b "$cidr" | cut -f2 -d=)

  IFS=. read -r a b c d <<< "$lo"
  IFS=. read -r e f g h <<< "$hi"

  # Generate array of addresses
  IPS=( $(eval "echo {$a..$e}.{$b..$f}.{$c..$g}.{$d..$h}") )
  # Strip the IP subnet network address from the front of the array
  IPS=("${IPS[@]:1}")
  # Strip the IP subnet broadcast address from the end of the array
  unset IPS[-1]
  # By convention, use the first element of the array as the gateway

  # Print the results
  # echo "${IPS[*]}"
}

# Test gen_ips() function
#IP_PREFIX="192.168"
#for (( i = 0; i < 10; i++ )); do
#  gen_ips "$IP_PREFIX.$i.0/27"
#done

# ToDo: Error checking here
# MAX_LOGICAL_SWITCHES <= 256 (Using 192.168.X as address space)
# MAX_PORTS_PER_LOGICAL_SWTICH <= 253 (Using /24 subnet, GW is used by router)

##############################################################################
# We expect to be running in the OVN sandbox environment here.
# The OVS switch is already present and the ovn-north/south 
# daemons are already running
##############################################################################

# Create a logical router
lr="${LOGICAL_ROUTER_NAME}0"
action "Creating logical router $lr" \
  ovn-nbctl lr-add lr0

## Create an array of IPv4 addresses for the logical router
#ROUTER_CIDR="10.0.0.0/24"
#gen_ips $ROUTER_CIDR
#router_subnet=("${IPS[@]}")
#log_success_msg "Assigned IPv4 subnet $ROUTER_CIDR to logical router $lr"

# Create an array of MAC addresses for the logical router
router_mac=("${UNIQUE_MACS[@]::$MAX_LOGICAL_SWITCHES}")
UNIQUE_MACS=("${UNIQUE_MACS[@]:$MAX_LOGICAL_SWITCHES}")
log_success_msg "Reserved ${#router_mac[@]} MAC addresses for logical router $lr"
# log_success_msg "Reserved ${#router_mac[@]} MAC addresses for logical router $lr (${#UNIQUE_MACS[@]} remaining)"
log_success_msg "[${router_mac[*]}]"

# Create a number of logical switches, attaching them to the logical router
for (( s = 1; s <= $MAX_LOGICAL_SWITCHES; s++ )); do

  # Setup logical switch/port naming
  ls="$LOGICAL_SWITCH_NAME$(printf "%03d" $s)"
  lsp="$ls-$LOGICAL_SWITCH_PORT_NAME$(printf "%03d" $s)"
  lsu="$ls-$lr"
  lrp="$lr-$ls"

  # Create an array of IPv4 addresses for the logical switch
  SWITCH_CIDR="192.168.$s.0/24"
  gen_ips $SWITCH_CIDR
  switch_subnet=("${IPS[@]}")
  switch_gw=${switch_subnet[0]}
  log_success_msg "Assigned IPv4 subnet $SWITCH_CIDR to logical switch $ls"
  
  # Create an array of MAC addresses for the logical switch
  switch_mac=("${UNIQUE_MACS[@]::$MAX_PORTS_PER_LOGICAL_SWITCH}")
  UNIQUE_MACS=("${UNIQUE_MACS[@]:$MAX_PORTS_PER_LOGICAL_SWITCH}")
  log_success_msg "Reserved ${#switch_mac[@]} MAC addresses for logical switch $ls"
  # log_success_msg "Reserved ${#switch_mac[@]} MAC addresses for logical switch $ls (${#UNIQUE_MACS[@]} remaining)"
  log_success_msg "[${switch_mac[*]}]"

  # ovn-nbctl ls-add sw0
  action "Creating logical switch $ls" \
    true
    # ovn-nbctl ls-add "$ls"

  # ovn-nbctl lrp-add lr0 lrp0 00:00:00:00:ff:01 192.168.0.1/24
  action "Adding port $lrp to router $lr" \
    true
    # ovn-nbctl lrp-add $lr $lrp ${router_mac[$((s-1))]} $switch_gw
  log_success_msg "IP: $switch_gw MAC: ${router_mac[$((s-1))]}"

  # ovn-nbctl lsp-add sw0 lrp0-attachment
  action "Adding uplink port $lsu to switch $ls" \
    true
    # ovn-nbctl lsp-add $ls $lsu

  # ovn-nbctl lsp-set-type lrp0-attachment router
  action "Setting uplink port $lsu to type \"router\"" \
    true
    # ovn-nbctl lsp-set-type $lsu router

  # ovn-nbctl lsp-set-addresses lrp0-attachment 00:00:00:00:ff:01
  action "Assigning MAC address ${router_mac[$((s-1))]} to port $lsu" \
    true
    # ovn-nbctl lsp-set-address $lsu ${router_mac[$((s-1))]}

  # ovn-nbctl lsp-set-options lrp0-attachment router-port=lrp0
  action "Setting port $lsu as \"router-port\"" \
    true
    # ovn-nbctl lsp-set-options $lsu router-port=$lrp

  # Create a number of ports on the logical switch for namespace/container use
  for (( p = 1; p <= $MAX_PORTS_PER_LOGICAL_SWITCH; p++ )); do

    # Setup logical switch port naming
    lsp="$ls-$LOGICAL_SWITCH_PORT_NAME$(printf "%03d" $p)"

    # ovn-nbctl lsp-add sw0 sw0-port1
    action "Adding port $lsp to switch $ls" \
      true
      # ovn-nbctl lsp-add $ls $lsp

    # ovn-nbctl lsp-set-addresses sw0-port1 "50:54:00:00:00:01 192.168.0.2"
    action "Assigning IP/MAC addresses to port $lsp" \
      true
      # ovn-nbctl lsp-set-address $lsp "$mac $ip"
      # ovn-nbctl lsp-set-address $lsp "${switch_mac[$((p-1))]} ${switch_subnet[$p]}"
    log_success_msg "IP: ${switch_subnet[$p]} MAC: ${switch_mac[$((p-1))]}"
  done
done

# View a summary of the configuration
printf "\n=== ovn-nbctl show ===\n\n"
ovn-nbctl show
printf "\n=== ovn-nbctl show with wait hv ===\n\n"
ovn-nbctl --wait=hv show
printf "\n=== ovn-sbctl show ===\n\n"
ovn-sbctl show

exit 0

# Show the results
log_success_msg "Final OVS bridge configuration"
ovs-vsctl show

exit 0



ovn-nbctl lrp-add lr0 lrp1 00:00:00:00:ff:02 11.0.0.1/24
ovn-nbctl lsp-add sw1 lrp1-attachment
ovn-nbctl lsp-set-type lrp1-attachment router
ovn-nbctl lsp-set-addresses lrp1-attachment 00:00:00:00:ff:02
ovn-nbctl lsp-set-options lrp1-attachment router-port=lrp1

ovs-vsctl add-port br-int p1 -- \
    set Interface p1 external_ids:iface-id=sw0-port1
ovs-vsctl add-port br-int p2 -- \
    set Interface p2 external_ids:iface-id=sw1-port1

# View a summary of the configuration
printf "\n=== ovn-nbctl show ===\n\n"
ovn-nbctl show
printf "\n=== ovn-nbctl show with wait hv ===\n\n"
ovn-nbctl --wait=hv show
printf "\n=== ovn-sbctl show ===\n\n"
ovn-sbctl show
